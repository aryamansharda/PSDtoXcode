#target photoshop

//This program only works in Photoshop CS5 onwards
if (documents.length == 0) {
    alert("Please open a .psd file.");
} else {

	//The application needs a reference to the storyboard file in order to add the new view controller to it
    function filterFiles(file) {
        if (file.constructor.name == "Folder") {
            return true
        }
        if (file.name.match(/\.storyboard$/)) {
            return true
        }
        return false;
    }

    var selectedFile = File.openDialog("Please choose the storyboard file.", filterFiles, false);

    if (!selectedFile) {
        alert("You have neglected to choose a .storyboard file. Please re-open your Photoshop file and select a .storyboard file.");
        activeDocument.close(SaveOptions.DONOTSAVECHANGES);
    }

    var f = new File(selectedFile);
    f.open("r");
    var str = f.read();
    f.close();

    //Created a backup of the existing .storyboard file in case an error occurs or the storyboard file is corrupted
    var a = new File(selectedFile + "backup");
    a.open('w');
    a.writeln(str);
    a.close();

    try {
        var prefix;
        var suffix;
        var addedToStoryboard = false;

        //All layers in Photoshop must be rasterized in order for the program to process them
        //The code in this function is automatically generated by Photoshop 
        function raterizeLayerStyle() {
            var idrasterizeLayer = stringIDToTypeID("rasterizeLayer");
            var desc5 = new ActionDescriptor();
            var
                idnull = charIDToTypeID("null");
            var ref4 = new ActionReference();
            var idLyr = charIDToTypeID("Lyr ");
            var idOrdn =
                charIDToTypeID("Ordn");
            var idTrgt = charIDToTypeID("Trgt");
            ref4.putEnumerated(idLyr, idOrdn, idTrgt);
            desc5.putReference(
                idnull, ref4);
            var idWhat = charIDToTypeID("What");
            var idrasterizeItem = stringIDToTypeID("rasterizeItem");
            var idlayerStyle =
                stringIDToTypeID("layerStyle");
            desc5.putEnumerated(idWhat, idrasterizeItem, idlayerStyle);
            executeAction(idrasterizeLayer,
                desc5, DialogModes.NO);
        }

        //Generates a "unique" 10 character long alpha-numeric string used to uniquely identify all UI components in Xcode
        function generateUniqueID() {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

            for (var i = 0; i < 10; i++)
                text += possible.charAt(Math.floor(Math.random() * possible.length * i));

            return text;
        }

        //Xcode represents the layer hierarchy in the opposite order of Photoshop
        //In order to get the view hierarchy to match, all of the layers must be reversed prior to being exported
        function reverseLayers() {
            var layers = activeDocument.layers;
            var layersArray = [];
            var len = layers.length;

            // Store all layers in an array
            for (var i = 0; i < len; i++) {
                layersArray.push(layers[i]);
            }

            // Sort layer top to bottom
            layersArray.reverse();

            for (i = 0; i < len; i++) {
                layersArray[i].move(layers[i], ElementPlacement.PLACEBEFORE);
            }
        };


        function openFile() {
            f.open("r");
            var str = f.read();

            prefix = str.substr(0, str.indexOf('<scenes>') + 8);
            suffix = str.substr(str.indexOf('<scenes>') + 8, str.length -
                str.indexOf('<scenes>') + 8 - 1);

            prefix = prefix + "\"<!--View Controller--> <scene sceneID=\"" + generateUniqueID() + "\"> <objects> <viewController id=\"" + generateUniqueID() + "\" sceneMemberID=\"viewController\"> <layoutGuides> <viewControllerLayoutGuide type=\"top\" id=\"" + generateUniqueID() + "\"/> <viewControllerLayoutGuide type=\"bottom\" id=\"" + generateUniqueID() + "\"/> </layoutGuides> <view key=\"view\" contentMode=\"scaleToFill\" id=\"" + generateUniqueID() + "\"> <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"320\" height=\"568\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/><subviews>";
            suffix = "</subviews> <color key=\"backgroundColor\" white=\"1\" alpha=\"1\" colorSpace=\"custom\" customColorSpace=\"calibratedWhite\"/> </view> </viewController> <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"" + generateUniqueID() + "\" sceneMemberID=\"firstResponder\"/> </objects> <point key=\"canvasLocation\" x=\"0\" y=\"0\"/> </scene>" + suffix;
            f.close();
        }

        function hexToRgbRed(hex) {
            var bigint = parseInt(hex, 16);
            var r = (bigint >> 16) & 255;

            return r / 255;
        }

        function hexToRgbGreen(hex) {
            var bigint = parseInt(hex, 16);
            var g = (bigint >> 8) & 255;

            return g / 255;
        }

        function hexToRgbBlue(hex) {
            var bigint = parseInt(hex, 16);
            var b = bigint & 255;

            return b / 255;
        }

        function removeAllEmptyArtLayers(obj) {
            for (var i = obj.artLayers.length - 1; 0 <= i; i--) {
                try {
                	//Tries to create a selection on the layer and if the selection is a rectangle of 0 width and 0 height, the layer is empty
                    if (obj.artLayers[i].kind == LayerKind.NORMAL && obj.artLayers[i].bounds[2] == 0 && obj.artLayers[i].bounds[3] == 0) {
                        obj.artLayers[i].remove();
                    }
                } catch (e) {}
            }

            //Removing empty layers nested in within groups
            for (var i = obj.layerSets.length - 1; 0 <= i; i--) {
                removeAllEmptyArtLayers(obj.layerSets[i]);
            }
        }

        function removeAllEmptyLayerSets(obj) {
            var foundEmpty = true;
            for (var i = obj.layerSets.length - 1; 0 <= i; i--) {
                if (removeAllEmptyLayerSets(obj.layerSets[i])) {
                    obj.layerSets[i].remove();
                } else {
                    foundEmpty = false;
                }
            }
            if (obj.artLayers.length > 0) {
                foundEmpty = false;
            }
            return foundEmpty;
        }

        function removeAllEmpty(docRef) {
            removeAllEmptyArtLayers(docRef);
            removeAllEmptyLayerSets(docRef);
        }

        app.bringToFront();

        //This is the main preprocessing step
        //We remove all empty layers recursively 
        removeAllEmpty(app.activeDocument);

        //We reverse the layers so they are added into Xcode in the same hierachical order
        reverseLayers();

        //We open the storyboard file and create a backup 
        openFile();

        //Configuring some basic Photoshop document settings
        var docRef = app.activeDocument;
        docRef.resizeImage(undefined, undefined, 72, ResampleMethod.NONE);
        app.preferences.rulerUnits = Units.PIXELS;

        var alreadyDone = false;

        //Checking if the design matches the necessary resolution the newest iPhone 
        if ((docRef.height == 1334) && (docRef.width == 750)) {

            alreadyDone = true;

            //Iterate through all Photoshop layers and export them at full resolution
            for (var x = 0; x < docRef.artLayers.length; x++) {
                var activeLay = docRef.artLayers[x];
                var newLayer = activeLay.duplicate();

                var date = new Date();
                var components = [
                    date.getYear(),
                    date.getMonth(),
                    date.getDate(),
                    date.getHours(),
                    date.getMinutes(),
                    date.getSeconds(),
                    date.getMilliseconds()
                ];

                //Generates a new ID
                //Even though this is hacky when Xcode loads the project again, these IDs all get reassigned anyways
                var id = components.join("");

                //We only want to rasterize layers that aren't text
                //For text layers, we can just copy the text font and size and export a label
                if (newLayer.kind != LayerKind.TEXT) {
                    newLayer.rasterize(RasterizeType.ENTIRELAYER);
                    docRef.activeLayer = newLayer;
                    raterizeLayerStyle();
                }

                newLayer.copy();

                //Getting the bounds of the element
                var tempWidth = (newLayer.bounds[2] - newLayer.bounds[0]);
                var tempHeight = (newLayer.bounds[3] - newLayer.bounds[1]);

                var tempWidthO = activeLay.bounds[2] - activeLay.bounds[0];
                var tempHeightO = activeLay.bounds[3] - activeLay.bounds[1];

                //If the layer name contains any permutations of the word button, add the button to the outputted view controller
                if ((docRef.artLayers[x].name.indexOf("button") > -1) || (docRef.artLayers[x].name.indexOf("bttn") > -1) || (docRef.artLayers[x].name.indexOf("btn") > -1)) {

					//Because we want a non-desctructive flow, we create a copy of each layer
                    //Here we need to remove the -copy suffix that Photoshop automatically adds when you duplicate a layer
                    var result = activeLay.name.replace(/\s/gi, "-");
                    result = result.replace("-copy", "");

                    //This is the XML to recreate the button in Xcode
                    prefix = prefix + "\n<button appearanceType=\"aqua\" opaque=\"NO\" contentMode=\"scaleToFill\" fixedFrame=\"YES\" contentHorizontalAlignment=\"center\" contentVerticalAlignment=\"center\" lineBreakMode=\"middleTruncation\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"" + generateUniqueID() + id + "\"> <rect key=\"frame\" x=\"" + newLayer.bounds[0] / 2 + "\" y=\"" + newLayer.bounds[1] / 2 + "\" width=\"" + tempWidth / 2 + "\" height=\"" + tempHeight / 2 + "\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/> <state key=\"normal\" image=\"" + result + ".png" + "\"> <color key=\"titleShadowColor\" white=\"0.5\" alpha=\"1\" colorSpace=\"calibratedWhite\"/> </state> </button>";
                    addedToStoryboard = true;
                } else if (docRef.artLayers[x].kind == LayerKind.TEXT) {

                	//For text layers, we just copy the styling instead of exporting any asset

                    var color;
                    var text;
                    var font;
                    var fontSize;
                    var fontFamilyStyle;

                    try {
                        font = newLayer.textItem.font;
                    } catch (e) {}

                    try {
                        fontFamilyStyle = app.fonts.getByName(font);
                    } catch (e) {}

                    try {
                        fontSize = parseInt(newLayer.textItem.size);
                    } catch (e) {
                        fontSize = 12;
                    }

                    try {
                        color = newLayer.textItem.color.rgb.hexValue;
                    } catch (e) {
                        color = '000000';
                    }

                    try {
                        text = docRef.artLayers[x].textItem.contents;
                        text = text.replace("&", "&amp;");

                    } catch (e) {}

                    //Parsing the exact font settings from Photoshop output
                    var n = font.indexOf("-");
                    var ending = font.substring(n + 1, font.length);

                    fontFamilyStyle = "" + fontFamilyStyle;
                    fontFamilyStyle = fontFamilyStyle.replace("[TextFont ", "");
                    fontFamilyStyle = fontFamilyStyle.replace("]", "");
                    fontFamilyStyle = fontFamilyStyle.replace(" " + ending, "");

                    //Adding the label to the outputted view controller
                    prefix = prefix + "\n<label appearanceType=\"aqua\" opaque=\"NO\" clipsSubviews=\"YES\" userInteractionEnabled=\"NO\" contentMode=\"left\" horizontalHuggingPriority=\"251\" verticalHuggingPriority=\"251\" fixedFrame=\"YES\" text=\"" + text + "\" lineBreakMode=\"tailTruncation\" numberOfLines=\"0\" baselineAdjustment=\"alignBaselines\" adjustsFontSizeToFit=\"NO\" preferredMaxLayoutWidth=\"42\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"" + generateUniqueID() + id + "\"> <rect key=\"frame\" x=\"" + newLayer.bounds[0] / 2 + "\" y=\"" + ((newLayer.bounds[1] / 2) - tempHeight / 4) + "\" width=\"" + tempWidth / 1.7 + "\" height=\"" + tempHeight + "\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/> <fontDescription key=\"fontDescription\" name=\"" + font + "\" family=\"" + fontFamilyStyle + "\" pointSize=\"" + fontSize / 2 + "\"/> <color key=\"textColor\" red=\"" + hexToRgbRed(color) + "\" green=\"" + hexToRgbGreen(color) + "\" blue=\"" + hexToRgbBlue(color) + "\" alpha=\"1\" colorSpace=\"calibratedRGB\"/> <nil key=\"highlightedColor\"/> </label>";

                    addedToStoryboard = true;
                    newLayer.remove();
                    continue;
                } else if ((docRef.artLayers[x].name.indexOf("image") > -1) || (docRef.artLayers[x].name.indexOf("img") > -1)) {

                	//The last supported file type is an iamge
                	//Here we just export it with the same name as the source layer
                    var result = activeLay.name.replace(/\s/gi, "-");

                    //Because we want a non-desctructive flow, we create a copy of each layer
                    //Here we need to remove the -copy suffix that Photoshop automatically adds when you duplicate a layer
                    result = result.replace("-copy", "");

                    prefix = prefix + "\n<imageView appearanceType=\"aqua\" userInteractionEnabled=\"NO\" contentMode=\"scaleToFill\" horizontalHuggingPriority=\"251\" verticalHuggingPriority=\"251\" fixedFrame=\"YES\" image=\"" + result + ".png" + "\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"" + generateUniqueID() + id + "\"> <rect key=\"frame\" x=\"" + newLayer.bounds[0] / 2 + "\" y=\"" + newLayer.bounds[1] / 2 + "\" width=\"" + tempWidth / 2 + "\" height=\"" + tempHeight / 2 + "\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/> </imageView>";
                    addedToStoryboard = true;
                }

                //The previous code handles adding the element to the Xcode project, now we need to export the asset itself
                if (docRef.artLayers[x].kind != LayerKind.TEXT) {

                	//We copy the asset over to a new empty layer
                    var myNewDoc = app.documents.add(tempWidth, tempHeight, 72, "exportedLayer", NewDocumentMode.RGB, DocumentFill.TRANSPARENT);

                    var targetLayer = myNewDoc.artLayers.add();
                    myNewDoc.paste();

                    targetLayer.opacity = activeLay.opacity;

                    //Assign output image properties
                    var options = new ExportOptionsSaveForWeb();
                    options.format = SaveDocumentType.PNG;
                    options.PNG8 = false;
                    options.transparency =
                        true;
                    options.optimized = true;

                    //Export the asset with the Xcode readible resolution suffix
                    myNewDoc.exportDocument(File(docRef.path + "/" + activeLay.name + '@3x.png'), ExportType.SAVEFORWEB, options);
                    myNewDoc.close(SaveOptions.DONOTSAVECHANGES);
                    newLayer.remove();
                }

            }

        }

        //Scaling down all of the layers to match the @2x resolution now
        try {
            var doc = app.activeDocument;
            var layers = doc.artLayers;
            var size = 66.5;

            for (var i = 0; i < doc.artLayers.length; i++) {

                var activeLayer = doc.artLayers.getByName(doc.artLayers[i].name);
                var orUnits = app.preferences.rulerUnits;
                app.preferences.rulerUnits = Units.PERCENT;
                activeLayer.resize(size, size, AnchorPosition.MIDDLECENTER);
                app.preferences.rulerUnits = orUnits;
            }
        } catch (e) {
            alert(e);
        }

        //If we've previously added the elements to Xcode in the @3x processing step, we don't need to add them again
        if (alreadyDone == false) {
            for (var x = 0; x < docRef.artLayers.length; x++) {
                var activeLay = docRef.artLayers[x];
                var newLayer = activeLay.duplicate();

                var date = new Date();
                var components = [
                    date.getYear(),

                    date.getMonth(),
                    date.getDate(),
                    date.getHours(),
                    date.getMinutes(),
                    date.getSeconds(),
                    date.getMilliseconds()
                ];

                var id = components.join("");

                if (!(newLayer.kind == LayerKind.TEXT)) {
                    newLayer.rasterize(RasterizeType.ENTIRELAYER);
                    docRef.activeLayer = newLayer;
                    raterizeLayerStyle();
                }

                newLayer.copy();
                var tempWidth = (newLayer.bounds[2] - newLayer.bounds[0]);
                var tempHeight = (newLayer.bounds[3] - newLayer.bounds[1]);

                var tempWidthO = activeLay.bounds[2] - activeLay.bounds[0];
                var tempHeightO = activeLay.bounds[3] - activeLay.bounds[1];


                if (alreadyDone == false) {

                    if ((docRef.artLayers[x].name.indexOf("button") > -1) || (docRef.artLayers[x].name.indexOf("bttn") > -1) || (docRef.artLayers[x].name.indexOf("btn") > -1)) {

                        var result = activeLay.name.replace(/\s/gi, "-");
                        result = result.replace("-copy", "");

                        prefix = prefix + "\n<button appearanceType=\"aqua\" opaque=\"NO\" contentMode=\"scaleToFill\" fixedFrame=\"YES\" contentHorizontalAlignment=\"center\" contentVerticalAlignment=\"center\" lineBreakMode=\"middleTruncation\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"" + generateUniqueID() + id + "\"> <rect key=\"frame\" x=\"" + newLayer.bounds[0] / 2 + "\" y=\"" + newLayer.bounds[1] / 2 + "\" width=\"" + tempWidth / 2 + "\" height=\"" + tempHeight / 2 + "\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/> <state key=\"normal\" image=\"" + result + ".png" + "\"> <color key=\"titleShadowColor\" white=\"0.5\" alpha=\"1\" colorSpace=\"calibratedWhite\"/> </state> </button>";
                        addedToStoryboard = true;
                    } else if (docRef.artLayers[x].kind == LayerKind.TEXT) {

                        var color;
                        var text;
                        var font;
                        var fontSize;
                        var fontFamilyStyle;

                        try {
                            font = newLayer.textItem.font;
                        } catch (e) {
                            //alert("FONT:" + e);
                        }

                        try {
                            fontFamilyStyle = app.fonts.getByName(font);
                        } catch (e) {
                            //alert("No luck.");
                        }

                        try {
                            fontSize = parseInt(newLayer.textItem.size);
                        } catch (e) {
                            fontSize = 12;
                        }

                        try {
                            color = newLayer.textItem.color.rgb.hexValue;
                        } catch (e) {
                            color = '000000';
                        }

                        try {
                            text = docRef.artLayers[x].textItem.contents;
                            text = text.replace("&", "&amp;");

                        } catch (e) {

                        }

                        var n = font.indexOf("-");
                        var ending = font.substring(n + 1, font.length);

                        fontFamilyStyle = "" + fontFamilyStyle;
                        fontFamilyStyle = fontFamilyStyle.replace("[TextFont ", "");
                        fontFamilyStyle = fontFamilyStyle.replace("]", "");
                        fontFamilyStyle = fontFamilyStyle.replace(" " + ending, "");

                        prefix = prefix + "\n<label appearanceType=\"aqua\" opaque=\"NO\" clipsSubviews=\"YES\" userInteractionEnabled=\"NO\" contentMode=\"left\" horizontalHuggingPriority=\"251\" verticalHuggingPriority=\"251\" fixedFrame=\"YES\" text=\"" + text + "\" lineBreakMode=\"tailTruncation\" numberOfLines=\"0\" baselineAdjustment=\"alignBaselines\" adjustsFontSizeToFit=\"NO\" preferredMaxLayoutWidth=\"42\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"" + generateUniqueID() + id + "\"> <rect key=\"frame\" x=\"" + newLayer.bounds[0] / 2 + "\" y=\"" + ((newLayer.bounds[1] / 2) - tempHeight / 4) + "\" width=\"" + tempWidth / 1.7 + "\" height=\"" + tempHeight + "\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/> <fontDescription key=\"fontDescription\" name=\"" + font + "\" family=\"" + fontFamilyStyle + "\" pointSize=\"" + fontSize / 2 + "\"/> <color key=\"textColor\" red=\"" + hexToRgbRed(color) + "\" green=\"" + hexToRgbGreen(color) + "\" blue=\"" + hexToRgbBlue(color) + "\" alpha=\"1\" colorSpace=\"calibratedRGB\"/> <nil key=\"highlightedColor\"/> </label>";

                        addedToStoryboard = true;
                        newLayer.remove();
                        continue;
                    } else if ((docRef.artLayers[x].name.indexOf("image") > -1) || (docRef.artLayers[x].name.indexOf("img") > -1)) {

                        var result = activeLay.name.replace(/\s/gi, "-");

                        result = result.replace("-copy", "");

                        prefix = prefix + "\n<imageView appearanceType=\"aqua\" userInteractionEnabled=\"NO\" contentMode=\"scaleToFill\" horizontalHuggingPriority=\"251\" verticalHuggingPriority=\"251\" fixedFrame=\"YES\" image=\"" + result + ".png" + "\" translatesAutoresizingMaskIntoConstraints=\"NO\" id=\"" + generateUniqueID() + id + "\"> <rect key=\"frame\" x=\"" + newLayer.bounds[0] / 2 + "\" y=\"" + newLayer.bounds[1] / 2 + "\" width=\"" + tempWidth / 2 + "\" height=\"" + tempHeight / 2 + "\"/> <autoresizingMask key=\"autoresizingMask\" flexibleMaxX=\"YES\" flexibleMaxY=\"YES\"/> </imageView>";
                        addedToStoryboard = true;
                    }

                    if (docRef.artLayers[x].kind != LayerKind.TEXT) {
                        var myNewDoc = app.documents.add(tempWidth, tempHeight, 72, "exportedLayer", NewDocumentMode.RGB, DocumentFill.TRANSPARENT);

                        var targetLayer = myNewDoc.artLayers.add();
                        myNewDoc.paste();

                        targetLayer.opacity = activeLay.opacity;

                        var options = new ExportOptionsSaveForWeb();
                        options.format = SaveDocumentType.PNG;
                        options.PNG8 = false;
                        options.transparency =
                            true;
                        options.optimized = true;

                        myNewDoc.exportDocument(File(docRef.path + "/" + activeLay.name + '@2x.png'), ExportType.SAVEFORWEB, options);
                        myNewDoc.close(SaveOptions.DONOTSAVECHANGES);
                        newLayer.remove();
                    }
                }

            }
        } else {
            for (var x = 0; x < docRef.artLayers.length; x++) {

            	//Goes through all layers and exports the relevant assets
                if (docRef.artLayers[x].kind != LayerKind.TEXT) {

                    var activeLay = docRef.artLayers[x];

                    var newLayer = activeLay.duplicate();
                    newLayer.rasterize(RasterizeType.ENTIRELAYER);
                    docRef.activeLayer = newLayer;
                    raterizeLayerStyle();
                    newLayer.copy();

                    var tempWidth = (newLayer.bounds[2] - newLayer.bounds[0]);
                    var tempHeight = (newLayer.bounds[3] - newLayer.bounds[1]);

                    var myNewDoc = app.documents.add(tempWidth, tempHeight, 72, "exportedLayer", NewDocumentMode.RGB, DocumentFill.TRANSPARENT);

                    var targetLayer = myNewDoc.artLayers.add();
                    myNewDoc.paste();

                    targetLayer.opacity = activeLay.opacity;

                    var options = new ExportOptionsSaveForWeb();
                    options.format = SaveDocumentType.PNG;
                    options.PNG8 = false;
                    options.transparency =
                        true;
                    options.optimized = true;

                    myNewDoc.exportDocument(File(docRef.path + "/" + activeLay.name + '.png'), ExportType.SAVEFORWEB, options);
                    myNewDoc.close(SaveOptions.DONOTSAVECHANGES);
                    newLayer.remove();
                }
            }
        }

        try {
            var doc = app.activeDocument;
            var layers = doc.artLayers;
            var size = 50;

            for (var i = 0; i < doc.artLayers.length; i++) {

                var activeLayer = doc.artLayers.getByName(doc.artLayers[i].name);
                var orUnits = app.preferences.rulerUnits;
                app.preferences.rulerUnits = Units.PERCENT;
                activeLayer.resize(size, size, AnchorPosition.MIDDLECENTER);
                app.preferences.rulerUnits = orUnits;
            }
        } catch (e) {
            alert(e);
        }


        for (var x = 0; x < docRef.artLayers.length; x++) {

            if (docRef.artLayers[x].kind != LayerKind.TEXT) {

                var activeLay = docRef.artLayers[x];

                var newLayer = activeLay.duplicate();
                newLayer.rasterize(RasterizeType.ENTIRELAYER);
                docRef.activeLayer = newLayer;
                raterizeLayerStyle();
                newLayer.copy();

                var tempWidth = (newLayer.bounds[2] - newLayer.bounds[0]);
                var tempHeight = (newLayer.bounds[3] - newLayer.bounds[1]);

                var myNewDoc = app.documents.add(tempWidth, tempHeight, 72, "exportedLayer", NewDocumentMode.RGB, DocumentFill.TRANSPARENT);

                var targetLayer = myNewDoc.artLayers.add();
                myNewDoc.paste();

                targetLayer.opacity = activeLay.opacity;

                var options = new ExportOptionsSaveForWeb();
                options.format = SaveDocumentType.PNG;
                options.PNG8 = false;
                options.transparency =
                    true;
                options.optimized = true;

                myNewDoc.exportDocument(File(docRef.path + "/" + activeLay.name + '.png'), ExportType.SAVEFORWEB, options);
                myNewDoc.close(SaveOptions.DONOTSAVECHANGES);
                newLayer.remove();
            }
        }

        //Outputs the new storyboard file
        //We take the original storyboard file, find where in the file to add the new view controller object
        //Create the XML for the new object and append all of these items to it
        //Then we add the remainder of the original storyboard file and export it
        //Effectively, we are just inserting the new view contorller XML definition into the XML that represents the storyboard
        var a = new File(selectedFile);
        a.open("e", "TEXT", "????");
        a.encoding = "UTF8";
        a.writeln(prefix + suffix);
        a.close();

        if (!addedToStoryboard) {
            alert("We were unable to add the elements to Xcode, this is most likely caused my incorrectly labeled Photoshop layers. Please label the layers correctly and run the tool again.");
        }

        activeDocument.close(SaveOptions.DONOTSAVECHANGES);
        alert("We've finished processing the file, check Xcode for the new interface.");
    } catch (e) {
        if (e.number == 8007) {
            activeDocument.close(SaveOptions.DONOTSAVECHANGES);
            alert("You've canceled the operation. We've removed our changes.");
        }

        if (e.number == 8800) {
            activeDocument.close(SaveOptions.DONOTSAVECHANGES);
            alert("Please refrain from altering the file while the program is in progress. This includes adding new layers and copying new information to the clipboard.");
        }
    }
}